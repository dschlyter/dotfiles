[user]
    name = David Schlyter
    email = dschlyter@gmail.com
[color]
    ui = auto
[color "branch"]
    current = yellow reverse
    local = yellow
    remote = green
[color "diff"]
    meta = yellow bold
    frag = magenta bold
    old = red bold
    new = green bold
    whitespace = red reverse
[color "status"]
    added = yellow
    changed = green
    untracked = cyan
[apply]
    whitespace=fix
[core]
    whitespace=-indent-with-non-tab,trailing-space,cr-at-eol
    excludesfile = ~/.gitignore
    editor = vim
    autocrlf = input
    # for some reason this value is always automatically re-indented with a tab instead of spaces, I give up on reseting it every time
	trustctime = false
[advice]
    statusHints = false
[branch]
    # When branching off a remote branch, automatically let the local branch track the remote branch
    autosetupmerge = true
    # Use rebase when pulling
    autosetuprebase = always
[fetch]
    prune = true
[diff]
    renames = copies
[push]
    default = current
# Enable the recording of resolved conflicts, so that identical hunks can be resolved automatically later on.
[rerere]
    enabled = true
[interactive]
    # remove need to press enter in interactive or add -p modes, requires library readkey to be installed
    singlekey = true
[alias]
    # shorthands with good defaults
    st = status -sb
    di = diff
    dic = diff --cached
    au = add -u
    cm = commit -v
    cma = !git cm --amend
    pu = push -u --follow-tags
    pufl = push --force-with-lease
    br = branch
    par = pull --rebase --autostash
    rb = rebase
    rba = rebase --autostash
    rbc = rebase --continue
    co = checkout
    cb = checkout -b
    cop = checkout -p
    com = checkout master
    cp = cherry-pick

    # entry point for custom scripts (for things that are too large to define inline here)
    # list contibutors with number of commits
    contribs = "!$HOME/.git-scripts/entry contribs"
    # checkout branch and prepare for review
    review = "!$HOME/.git-scripts/entry review"

    # diff with selection
    df = "!r() { git status --porcelain | awk '{print $2}' | fzf | xargs git diff; }; r"
    dg = "!r() { git status --porcelain | awk '{print $2}' | grep -i \"$1\" | xargs git diff; }; r"

    # log and display
    # nicely formatted log, default to 15 entries but another -n may override that
    # lgh only shows HEAD and ancestor commits
    # lg shows all branches
    lg = !git lh --all
    lh = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%ai) %C(bold blue)<%an>%Creset' --abbrev-commit -n 15
    ls = !git lh --stat
    ln = !git lh --no-merges
    ll = !git lg -n 9999
    lhl = !git lh -n 9999
    # log including all branchless (rebased, amended, dropped) commits
    la = !git lg $(git fsck --unreachable --no-reflog | grep commit | grep -o '[^ ]*$')
    mine = "!r() { git lg --author='David Schlyter'; }; r"
    # show the first commit from log that matches sha-prefix, eg. git sc 72F
    sc = "!r() { git log | grep 'commit '\"$1\" | head -n 1 | cut -d' ' -f2- | xargs git show; }; r"

    # commit
    # patched commit with a file review and untracked sanity check first
    pc = !bash -c 'git status && ( [[ ! "$(git ls-files --others --exclude-standard)" ]] || ( echo "!!! - Warning: Untracked files - !!! - press any key to confirm" && read -n 1 )) && [[ "$(git ls-files --modified)" ]] && git cm -p $1' -
    checkpoint = !git stash save --include-untracked checkpoint of WIP && git stash apply
    # wip commit, to be used in combination with post-checkout auto pop of all commits named "wip"
    wip = "!r() { git add -A; git commit -m 'wip-stash'; }; r"
    # blacklist, prevent files from getting commited (different from .gitignore in that they might already be tracked)
    blacklist = "!r() { echo \"$@\" > .gitblacklist }; r"
    # named stashes
    sshow = "!f() { git stash show stash^{/$*} -p; }; f"
    sapply = "!f() { git stash apply stash^{/$*}; }; f"
    srevert = "!f() { git sshow \"$@\" | git apply --reverse; }; f"
    # remove all whitespace changes
    rw=!sh -c 'git diff -U0 -w --no-color "$@" | git apply --cached --ignore-whitespace --unidiff-zero - && git checkout "${@:-.}" && git reset'
    bc = "!r() { git checkout -b $1 && git commit -p; }; r"

    # amend and rebase
    # amend without changing git commit message
    amend = commit --amend --reuse-message=HEAD
    pa = !git amend -p
    # --amend to a previous commit below HEAD
    fixup = !sh -c '(git diff-files --quiet || (echo "Unstaged changes, please commit or stash with --keep-index" && exit 1)) && COMMIT=$(git rev-parse $1) && git commit --fixup=$COMMIT && git rebase -i --autosquash $COMMIT~1' -
    fup = !sh -c 'git fixup "$(git select)"'
    select = "!r() { git log --pretty --oneline --decorate --color | fzf --ansi | awk '{print ""$""1}'; }; r"
    cps = "!r() { git cherry-pick $(git select); }; r"
    # checkout/reset back n commits
    con = "!r() { COUNT=$1; shift; git co HEAD~$COUNT $@; }; r"
    rsn = "!r() { COUNT=$1; shift; git reset HEAD~$COUNT $@; }; r"
    rsm = branch -f master origin/master
    # rebase the last n commits
    rbn = "!r() { git rebase -i HEAD~$1; }; r"
    # rebase on mainline

    # pushing
    # fast forward another branch and push both that and current (ie. double push develop+master)
    f2p = "!r() { BRANCH=\"$(git symbolic-ref --short -q HEAD)\"; git co $1 && git merge --ff-only \"$BRANCH\" && git push origin \"$1\" \"$BRANCH\"; }; r"

    # pulling changes more productively
    # fetch, prune removed remote branches and shortlog fetched changes
    fe = !sh -c 'PRE=${1:-$(git rev-parse origin/master)} && git fetch --tags --prune && git lh $PRE..$(git rev-parse origin/master) || true' -
    # utils for branch comparisons
    curr-br = rev-parse --abbrev-ref HEAD
    branch-exists = "!r() { git rev-parse $1 > /dev/null 2>&1; }; r"
    on = "!r() { test \"$(git curr-br 2> /dev/null)\" == \"$1\"; }; r"
    behind = "!r() { git merge-base --is-ancestor HEAD $1; }; r"
    same = "!r() { test $(git rev-parse $1) == $(git rev-parse $2); }; r"
    # get remote updates even with local uncommited changes (but abort on conflicts)
    ff = !sh -c 'git lazy-fe && git merge --ff-only'
    fr = !sh -c 'git lazy-fe && git rb --autostash'
    # forward to develop or master if current branch is merged
    fwd = "!r() { git behind origin/develop && ! git on develop && git dup && git co develop; }; r"
    fwm = "!r() { git behind origin/master && ! git on master && git mup && git co master; }; r"
    fw = "!r() { git fe; git ff 2> /dev/null; if git branch-exists develop; then git fwd; else git fwm; fi || true; }; r"
    # combined update all the things command
    u = !git fw && git brc
    # fast forward branch without checking them out
    up = !sh -c 'git lazy-fe $1 && git merge-base --is-ancestor $1 origin/$1 && ! git same $1 origin/$1 && git branch -f $1 origin/$1' -
    urb = "!r() { git up $1; git rebase --autostash $1; }; r"
    mup = !git up master
    mur = !git urb master
    ur = "!r() { git urb $(git branch-exists develop && echo develop || echo master); }; r"
    # lazy fetch, for having fetch in commands that may be chained together, without fetching multiple times
    last-fetch = "!r() { echo $(( $(date +%s) - $(${GNU_PREFIX}stat -c %Y .git/FETCH_HEAD) )); }; r"
    lazy-fe = "!r() { test $(git last-fetch) -gt 20 && git fe || true; }; r"

    # branch management
    bra = branch -a --sort=-committerdate --format='%(color:green)%(committerdate:relative)%(color:reset) %(color:red)%(objectname:short)%(color:reset) %(color:yellow)%(refname:short)%(color:reset) - %(contents:subject) - %(authorname) '
    braf = "!r() { git bra --color | fzf --ansi -e | awk '{print $5}' ; }; r"
    cof = "!r() { git braf | sed 's,origin/,,' | xargs git co ; }; r"
    # branch cleanup
    # delete or rename branch, both locally and remotely
    brd = "!r() { git branch -d $1; git push origin --delete $1; }; r"
    brm = !"r() { old_name=$(git curr-br) && git br -m $1 && git push origin :$old_name $1 && git su; }; r"
    # branch cleanup
    brc = !sh -c 'git branch --merged | grep -v "\\*" | grep -v "master" | grep -v "develop" | xargs -n 1 git branch -d' - # git branch -d'
    # quick alias for setting upstream
    su = !sh -c 'git branch -u "origin/$(git curr-br)"'
    # when you forget to create a feature branch and push on main
    rbr = !"r() { branch=\"$(git symbolic-ref --short HEAD)\" && git branch -m \"$1\" && git branch \"$branch\" \"origin/$branch\"; }; r"

    # tag management
    # tag a version, make sure it is an annotated tag, but avoid hassle with duplicating version in commit message
    tv = "!f() { git tag -m \"Version $1\" $1; }; f"
    tagd = "!r() { git tag -d $1; git push origin --delete $1; }; r"

    # github
    github-url = !echo "https://github.com/$(git config --get remote.origin.url | sed -e 's/.*://' -e 's/[.]git$//')"
    pr = !git same origin/$(git curr-br) $(git curr-br) || git pu && open "$(git github-url)/compare/$(git curr-br)?expand=1"

    # gitflow stuff (for those unfortunate enough to use gitflow)
    mmd = !git co develop && git merge --ff-only && git co master && git merge --ff-only && git merge develop
    # check unreleased features on develop branch
    features = !git lh master..develop --merges -n 9999
    # check failures to merge changes into develop
    fail = !git lh develop..master
    local = !git lg --branches --not --remotes
    dup = !git up develop
    dur = !git urb develop
    durp = !git dir && git pufl

    # multi-repo stuff
    # everything i have done the last month. there is an echo and inverse grep empty lines to make sure newlines are properly inserted
    allmine = "!r() { find . -name .git -exec sh -c \"cd {}; git log --author='David Schlyter' --since='2 month' --date=iso --pretty=format:'%cd {} %s'; echo \" ';' | grep -v '^$' | sort; }; r"
    logall = "!r() { find . -name .git -exec sh -c \"cd {}; git log --since='2 month' --date=iso --pretty=format:'%cd %an {} %s'; echo \" ';' | grep -v '^$' | sort; }; r"

    cleanout = !git clean -Xdf && git gc
    yolo = !git add -A && git commit -m \"$(curl -s whatthecommit.com/index.txt)\" && git push
[web]
    browser = google-chrome
[include]
    # local override of settings, file relative to .gitconfig. requires git 1.7.10+
    # this breaks in EGit :@
    path = .gitconfig_local
[init]
    templatedir = ~/.git_template
[credential]
    helper = cache --timeout=3600
[merge]
    tool = vimdiff
[mergetool]
    keeptemporaries = false
    keepbackups = false
    prompt = false
    trustexitcode = false
