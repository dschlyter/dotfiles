#!/bin/bash

# common shell settings that should work in both zsh and bash

#
# Variables and aliases
#

# Env Variables

export EDITOR="vim"
export VISUAL="vim"
export PAGER="less"

_add_to_path() {
    if [[ ! "$PATH" == *$1* ]]; then
        export PATH="$PATH:$1"
    fi
}

_add_to_path "$HOME/bin"
_add_to_path "$HOME/code/bin"
_add_to_path "$HOME/local/bin"
_add_to_path "$HOME/code/server-setup/bin"
_add_to_path "/opt/sudo"

add_to_path() {
    echo "_add_to_path '$(realpath $1)'" >> ~/.shellrc_local
}

# Aliases

alias ll='ls -l'
alias la='ls -a'
alias lla='ls -la'
alias lal='ls -la'
alias lt='ls -ltr'

alias plz='sudo $(fc -ln -1)'
alias se='sudoedit'
alias vims='vim -S .vimsession'
alias i='unset HISTFILE'

alias gitroot='cd $(git rev-parse --show-cdup)'
alias inet="ifconfig | grep -E '(^[a-z])|inet ' | grep -B 1 'inet '"

## Flags on by default
alias locate='locate -i'
alias mv='mv -i'
alias cp='${GNU_PREFIX}cp -i'
alias tig='tig --all'

alias erc="vim ~/.shellrc* ~/.zshrc* ~/.bashrc; rc"

#
# Utility functions
#

export TIME_STYLE=long-iso # iso8601 for ls
ls() {
    ${GNU_PREFIX:-/bin/}ls -h --color=auto --group-directories-first "$@"
}

# Override defaults

# Default to date -Is if no args are supplied
# iso-8601 is the one true date format
date() {
    BINARY=/bin/date
    BREW_BINARY=/usr/local/bin/gdate
    if [ -f $BREW_BINARY ]; then
        BINARY=$BREW_BINARY
    fi
    if [ "$*" ]; then
        $BINARY $*
    else
        $BINARY -Is
    fi
}

st() {
    ssh -t "$@" tmux
}

p() {
    DOC=$1
    if [ -n "$(echo ~/docs/plans/$DOC*)" ]; then
        vim ~/docs/plans/"$DOC"*
    else
        if ! [[ $DOC == *.txt ]]; then
            DOC="$DOC.txt"
        fi

        vim ~/docs/plans/"$DOC"
    fi
}

ckl() {
    cd ~/docs

    DOC="$(echo ~/docs/notes/checklists/$1* | cl 1)"
    DOC_COPY=${2:-"$(echo $DOC | sed -e "s,.*/,,")"}

    cp "$DOC" "$DOC_COPY"
    vim "$DOC_COPY"
}

vimd() {
    rm "$HOME/tmp/$1.swp"
    vim "$1"
}

# Functional-style helpers

# print specific column(s)
# ie. echo a b c d e | cl 2 4 5
cl() {
    # print $ before first arg and join remaining with ',$'
    # replace -X with NF+1-X to allow printing last, second to last column etc
    COLS=$(echo "\$$*" | sed -e 's/ /,$/g' | sed -E 's/-([0-9])+/(NF+1-\1)/g')
    awk "{print $COLS}"
}

take() {
    head -n $1
}

drop() {
    tail -n +$(($1 + 1))
}

nth () {
    sed -n "${1}p"
}

# distinct lines without requiring sort like: sort | uniq
distinct() {
    awk '!seen[$0]++'
}

# each word on one line
flatten() {
    xargs -n 1 echo
}

# many lines to single line
chunk() {
    LINE_GROUP_SIZE="$(test $1 && echo -L $1)"
    xargs $LINE_GROUP_SIZE echo
}

# Exploring the file system

md() {
    mkdir -p $1
    cd $1
}

u() {
    LEVELS=${1:-1}
    for i in {1..$LEVELS}; do
        cd ..
    done
}

function c() {
    s "$@"

    if [ -d "$1" ]; then
        cd "$1"
    fi
}

# explore a file tree with a combined ls and cat
function s() {
    if [ -d "$1" ]; then
        ls "$@"
    else
        cat "$@"
    fi
}

fixenc() {
    mv "$1" "$1.orig"
    iconv -f ISO-8859-1 -t UTF-8 "$1.orig" > "$1"
}

ss() {
    if [ -z "$1" ]; then
        echo "Usage $0 myScript.sh"
        return 1
    fi

    cp -i ~/.dotfiles/script_template.sh "$1" && $EDITOR "$1"
}

grab() {
    sudo chown -R ${USER} ${@:-.}
}

# allows one or multiple files to be "tagged"
# then used in other commands like: j otherdir; mv $=TAG .
tag() {
    if [[ "$@" == "" ]]; then
        echo "$TAG"
        return
    fi

    BASE=""
    if [[ "$1" == "-a" ]]; then
        BASE="$TAG\n"
        shift
    fi
    export TAG="$BASE$(realpath "$@")"
}
# a bit convoluted to work both in zsh and bash
alias cpt='echo "$TAG" | xargs -L 1 -i cp {} .'
alias mvt='echo "$TAG" | xargs -L 1 -i mv {} .'

# Various helpers

retry() {
    while true; do
        eval $* && return 0
        echo "Exit $? - Retrying in 1 second"
        sleep 1
    done
}

loop() {
    COUNT=$1
    shift
    for i in $(seq $COUNT); do
        eval "$@"
    done
}

serve() {
    PORT=${1:-8000}
    python -m SimpleHTTPServer "$PORT"
}

genpass() {
    PWLEN="${1:-60}"
    openssl rand -base64 $PWLEN | head -c $PWLEN
    echo
}

# because "time" does not always work for shell builtins etc
timing() {
    local PREV_TIMING="$LAST_TIMING"
    LAST_TIMING="$(date +%s%N)"
    if [ -n "$*" ] && [ "$PREV_TIMING" ]; then
        echo "Timing $*: $((($LAST_TIMING - $PREV_TIMING) / 1000000))"
    fi
}

#
# Docker utils
#

d() {
    docker "$@"
}

# alias docker to docker-restricted if available, when running as sudo alias will be ignored
if type docker-restricted &> /dev/null; then
    alias docker="sudo $(which docker-restricted)"
else
    dcleanup(){
        docker rm -v $(docker ps --filter status=exited -q 2>/dev/null) 2>/dev/null
        docker rmi $(docker images --filter dangling=true -q 2>/dev/null) 2>/dev/null
    }

    # "docker stats" with names instead of hash, until https://github.com/docker/docker/issues/20973 is solved
    dstat() {
        docker stats $(docker ps --format={{.Names}})
    }

    dports() {
        docker inspect "$1" | jq '.[].HostConfig.PortBindings'
    }
fi

source_if_exists() {
    if [ -f "$1" ]; then
        source "$1"
    fi
}

if type kubectl &> /dev/null; then
    source_if_exists ~/.kubectl_aliases
fi

#
# Autojump with fasd
#

export _FASD_IGNORE="fasd echo" # don't ignore ls history when finding files
fasd_setup() {
    local FASD_SH=~/.fasd.sh

    if [ -f $FASD_SH ]; then
        source $FASD_SH
        eval "$(fasd --init auto)"

        alias j="z"
        alias v="f -e vim -B viminfo"
        unalias s # used by function
        unalias d # used by function
    fi
}

# Source right away with bash, for zsh we need to wait for autocomplete to setup properly
if [ "$BASH_VERSION" ]; then
    fasd_setup
fi

#
# Local overrides (note: this may be overridden by again .bashrc or .zshrc)
#

source_if_exists ~/.shellrc_linux
source_if_exists ~/.shellrc_local
