#!/bin/bash

# common shell settings that should work in both zsh and bash

#
# Variables and aliases
#

# Env Variables

export EDITOR="vim"
export VISUAL="vim"
export PAGER="less"
# start on Mondays when using gcal
export GCAL="-s1"
export LS_COLORS

_add_to_path() {
    if [[ ! "$PATH" == *$1* ]]; then
        export PATH="$PATH:$1"
    fi
}

_add_to_path "$HOME/bin"
_add_to_path "$HOME/code/bin"
_add_to_path "$HOME/local/bin"
_add_to_path "$HOME/code/jenkins-seed/bin"
_add_to_path "/opt/sudo"

add_to_path() {
    echo "_add_to_path '$(realpath $1)'" >> ~/.shellrc_local
}

path() {
    echo "$PATH" | tr ":" "\n"
}

# Aliases

alias ll='ls -l'
alias la='ls -a'
alias lla='ls -la'
alias lal='ls -la'
alias lt='ls -ltr'
alias ltr='ls -ltr **/*(.)'
alias ltd='ls -dltr */'
alias lv='ls -v'

alias td='tree -d -L 3'

alias g="git"
alias st="git st"
alias di="git diff"
alias lg="git lg"
alias add="git add"
alias ai="git add -i"
alias fe="git fe"
alias rb="git rb"
alias cm="git cm"
alias pc="git pc"
alias merge="git merge"
alias pu="git pu"

alias plz='sudo $(fc -ln -1)'
alias se='sudoedit'
alias vims='vim -S .vimsession'
alias i='unset HISTFILE'

alias groot='cd "./$(git rev-parse --show-cdup)"'
alias inet="ifconfig | grep -E '(^[a-z])|inet ' | grep -B 1 'inet '"

## Flags on by default
alias locate='locate -i'
alias mv='mv -i'
alias cp='${GNU_PREFIX}cp -i'
alias tig='tig --all'

alias erc="vim ~/.shellrc* ~/.zshrc* ~/.bashrc; rc"

alias mt="mvn dependency:tree"
alias mp="mvn clean package"
alias mi="mvn clean install"
alias mia="mvn -Dmaven.test.failure.ignore=true --fail-at-end clean install"
alias gpl="gradle publishToMavenLocal"
alias x="session ./run.sh"

alias speedtest='time wget --output-document=/dev/null http://speedtest.tele2.net/100MB.zip'

#
# Utility functions
#

export TIME_STYLE=long-iso # iso8601 for ls
ls() {
    ${GNU_PREFIX:-/bin/}ls -h --color=auto --group-directories-first "$@"
}

# cross platform get ip https://stackoverflow.com/questions/13322485/how-to-get-the-primary-ip-address-of-the-local-machine-on-linux-and-os-x
my_ip() {
    ifconfig | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1' | head -n 1
}

# git diff can be used as a colorized diff on any files, but autocomplete breaks so let's create a little alias
gdiff() {
    git diff "$@"
}

# Override defaults

# Default to date -Is if no args are supplied
# iso-8601 is the one true date format
date() {
    BINARY=/bin/date
    BREW_BINARY=/usr/local/bin/gdate
    if [ -f $BREW_BINARY ]; then
        BINARY=$BREW_BINARY
    fi
    if [ "$*" ]; then
        $BINARY "$@"
    else
        $BINARY -Is
    fi
}

sst() {
    ssh -t "$@" tmux
}

tmux-d() {
    tmux ls | cl 1 | tr -d ":" MAP tmux detach -s
}

vpn() {
    REMOTE_HOST="${1:-$(cat ~/.ssh/config | grep Host | take 1 | cl 2)}"
    REMOTE_USER="$(cat ~/.ssh/config | dropUntil "Host $REMOTE_HOST" | takeUntil "Host " 2 | grep User | take 1 | cl 2)"
    if [ -z "$REMOTE_HOST" ] || [ -z "$REMOTE_USER" ]; then
        echo "Did not find host and corresponding user in .ssh/config"
        return
    fi
    REMOTE="$REMOTE_USER@$REMOTE_HOST"
    echo "Creating vpn to $REMOTE"
    sshuttle -r "$REMOTE" --dns 0.0.0.0/0
}

addkey() {
    # you can pass flags like -p 4711  or -i custom-key
    ssh "$@" bash -c "mkdir -p .ssh; tee -a .ssh/authorized_keys" < ~/.ssh/id_rsa.pub
}

p() {
    DOC=$1
    if [ -n "$(echo ~/docs/plans/"$DOC"*)" ]; then
        if [[ "$2" == "k" ]]; then
            kvim ~/docs/plans/"$DOC"*
        else
            vim ~/docs/plans/"$DOC"*
        fi
    else
        if ! [[ $DOC == *.txt ]]; then
            DOC="$DOC.txt"
        fi

        vim ~/docs/plans/"$DOC"
    fi
}

ckl() {
    cd ~/docs

    DOC="$(echo ~/docs/notes/checklists/$1* | cl 1)"
    DOC_COPY=${2:-"$(echo $DOC | sed -e "s,.*/,,")"}

    cp "$DOC" "$DOC_COPY"
    vim "$DOC_COPY"
}

vimd() {
    rm "$HOME/tmp/$1.swp"
    vim "$1"
}

# Functional-style helpers

# print specific column(s)
# i.e. echo a b c d e | cl 2 4 5
cl() {
    # print $ before first arg and join remaining with ',$'
    # replace -X with NF+1-X to allow printing last, second to last column etc
    COLS=$(echo "\$$*" | sed -e 's/ /,$/g' | sed -E 's/-([0-9])+/(NF+1-\1)/g')
    awk "{print $COLS}"
}

nth () {
    sed -n "${1}p"
}

take() {
    head -n "$1"
}

drop() {
    tail -n +$(($1 + 1))
}

taker() {
    tail -n "$1"
}

dropr() {
    "${GNU_PREFIX}"head -n -"$1"
}

takeUntil() {
    COUNT=${2:-1}
    awk "BEGIN {p=0}; /$1/ {p+=1}; p < $COUNT"
}

dropUntil() {
    COUNT=${2:-1}
    awk "BEGIN {p=0}; /$1/ {p+=1}; p >= $COUNT"
}

dropLong() {
    sed '/^.\{200\}./d'
}

# distinct lines without requiring sort like: sort | uniq
distinct() {
    awk '!seen[$0]++'
}

# each word on one line
flatten() {
    xargs -n 1 echo
}

# many lines to single line
chunk() {
    LINE_GROUP_SIZE="$(test "$1" && echo -L "$1")"
    xargs -d '\n' "$LINE_GROUP_SIZE" echo
}

# remove empty lines
trim() {
    sed '/^[ \t]*$/d'
}

# reverse input
alias reverse=tac

# Exploring the file system

md() {
    mkdir -p "$1"
    cd "$1" || return
}

tp() {
    tree -P "*$1*"
}

# cd to the dir of a file or command
cdt() {
    FILE="$1"
    if ! [ -e "$FILE" ]; then
        echo "no file"
        FILE="$(where "$FILE")"
    fi

    cd "$(dirname "$FILE")" || return 1
}

# raise a dir one level, having it consume the parent dir
raise() {
    if [[ ! -d "$1" ]]; then
        echo "Usage: raise dir-to-be-removed"
        return 0
    fi
    tmp="$1-raised-tmp"
    # rename to avoid the common name conflict with nested dirs
    mv "$1" "$tmp"
    mv "$tmp"/* "$tmp"/..
    rmdir "$tmp"
}

u() {
    if [ -z "$1" ]; then
        cd ..
    else
        PARENT_MATCH="$(pwd | grep -Eo ".*$1[^/]*/" )"
        if [ -n "$PARENT_MATCH" ]; then
            cd "$PARENT_MATCH" || return
        fi
    fi
}

function c() {
    s "$@"

    if [ -d "$1" ]; then
        cd "$1" || return
    fi
}

# explore a file tree with a combined ls and cat
function s() {
    if [ -d "$1" ]; then
        ls "$@"
    else
        cat "$@"
    fi
}

# Seamless switch in and out of n

export NNN_TMPFILE="/tmp/nnn"
n() {
    nnn "$@"

    if [ -f $NNN_TMPFILE ]; then
        . $NNN_TMPFILE
        rm $NNN_TMPFILE
    fi
}

# Other file helpers

tabsvsspaces() {
    echo "Tabs: $(grep -r "^\\t" . | wc -l)"
    echo "Spaces: $(grep -r "^  " . | wc -l)"
}

fixenc() {
    mv "$1" "$1.orig"
    iconv -f ISO-8859-1 -t UTF-8 "$1.orig" > "$1"
}

ss() {
    if [ -z "$1" ]; then
        echo "Usage $0 myScript.sh"
        return 1
    fi

    cp -i ~/.dotfiles/script_template.sh "$1" && $EDITOR "$1"
}

pys() {
    if [ -z "$1" ]; then
        echo "Usage $0 myScript"
        return 1
    fi

    cp -i ~/.dotfiles/script_template.py "$1" && $EDITOR "$1"
}

grab() {
    sudo chown -R "${USER}" "${@:-.}"
}

# allows one or multiple files to be "tagged"
# then used in other commands like: j otherdir; mv $=TAG .
tag() {
    if [[ "$*" == "" ]]; then
        echo "$TAG"
        return
    fi

    BASE=""
    if [[ "$1" == "-a" ]]; then
        BASE="$TAG\n"
        shift
    fi
    export TAG="$BASE$(realpath "$@")"
}

# a bit convoluted to work both in zsh and bash
alias cpt='echo "$TAG" | xargs -L 1 -i cp {} .'
alias mvt='echo "$TAG" | xargs -L 1 -i mv {} .'

alias agh="ag --hidden"

# jump directly to a line in a file in vim
vag() {
    vim "+silent /$*" $(ag -l "$@")
}

vagh() {
    vim "+silent /$*" $(ag --hidden -l "$@")
}

# Various helpers

retry() {
    while true; do
        eval "$@" && return 0
        echo "Exit $? - Retrying in 1 second"
        sleep 1
    done
}

loop() {
    COUNT=$1
    shift
    for _ in $(seq "$COUNT"); do
        eval "$@"
    done
}

serve() {
    PORT=${1:-8000}
    python -m SimpleHTTPServer "$PORT"
}

genpass() {
    PWLEN="${1:-60}"
    openssl rand -base64 "$PWLEN" | head -c "$PWLEN"
    echo
}

# because "time" does not always work for shell builtins etc
timing() {
    local PREV_TIMING="$LAST_TIMING"
    LAST_TIMING="$(date +%s%N)"
    if [ -n "$*" ] && [ "$PREV_TIMING" ]; then
        echo "Timing $*: $(((LAST_TIMING - PREV_TIMING) / 1000000))"
    fi
}

#
# Docker utils
#

alias d=docker
alias dco=docker-compose

drun() {
    docker run -it --rm --name "$1" "$1"
}

dsh() {
    CONTAINER="$(docker ps --filter name="$1" --format "{{.ID}}" | head -n 1)"
    docker exec -it "$CONTAINER" bash
}

# alias docker to docker-restricted if available, when running as sudo alias will be ignored
if type docker-restricted &> /dev/null; then
    alias docker="sudo $(which docker-restricted)"
else
    dcleanup(){
        docker rm -v $(docker ps --filter status=exited -q 2>/dev/null) 2>/dev/null
        docker rmi $(docker images --filter dangling=true -q 2>/dev/null) 2>/dev/null
    }

    # "docker stats" with names instead of hash, until https://github.com/docker/docker/issues/20973 is solved
    dstat() {
        docker stats $(docker ps --format={{.Names}})
    }

    dports() {
        docker inspect "$1" | jq '.[].HostConfig.PortBindings'
    }
fi

source_if_exists() {
    if [ -f "$1" ]; then
        source "$1"
    fi
}

if type kubectl &> /dev/null; then
    source_if_exists ~/.kubectl_aliases
fi

#
# Autojump with fasd
#

export _FASD_IGNORE="fasd echo" # don't ignore ls history when finding files
fasd_setup() {
    local FASD_SH=~/.fasd.sh

    if [ -f $FASD_SH ]; then
        source "$FASD_SH"
        eval "$(fasd --init auto)"

        alias j="z"
        alias v="f -e vim -B viminfo"
        unalias s # used by function
        unalias d # used by function
    fi
}

# Source right away with bash, for zsh we need to wait for autocomplete to setup properly
if [ "$BASH_VERSION" ]; then
    fasd_setup
fi

#
# Local overrides (note: this may be overridden by again .bashrc or .zshrc)
#

source_if_exists ~/.shellrc_linux
source_if_exists ~/.shellrc_local
