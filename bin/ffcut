#!/usr/bin/env python3

import argparse
import subprocess
import textwrap
import os
import unittest
import sys
import shutil
import time
from typing import List


def main():
    # https://docs.python.org/3/library/argparse.html
    main_p = argparse.ArgumentParser(description='Simple cut and merge utility. Provide a list of files and optionally timestamps.',)

    main_p.set_defaults(handler=cut)

    main_p.add_argument('files_and_times', nargs='+', help='ffcut file1 [00:00 00:10] [00:20 00:30] [file2] ...')
    main_p.add_argument('--copy', action='store_true', help='copy instead of reencoding, only supported for single file')

    main_p.add_argument('--av', action='store_true', help='1080p with av1 libsvtav1, 30 crf - approx 6M bitrate')
    main_p.add_argument('--av-mid', action='store_true', help='1080p with av1 libsvtav1, 39 crf - approx 3M bitrate')

    main_p.add_argument('--mid', action='store_true', help='1080p with libx264, 3M bitrate')
    main_p.add_argument('--smid', action='store_true', help='720p with libx264, 2M bitrate')
    main_p.add_argument('--small', action='store_true', help='720p with hevc_nvenc (GPU), 42 cq')
    main_p.add_argument('--smaller', action='store_true', help='720p with libx264, 28 crf')
    main_p.add_argument('--smallest', action='store_true', help='720p with libx265, 28 crf')

    main_p.add_argument('--scale', help='horizontal scale to use for small/mid cuts, default is 1920 or 1280 depending on preset')
    main_p.add_argument('--quality', type=int, help='quality to use for -crf (cpu, x264 default 23 ~= av1 30) or -cq (gpu, different scale 23 crf ~= 36 cq for x264)')
    main_p.add_argument('--mv', '-m', action='store_true', help='move to subdirs when done')

    parsed_args = main_p.parse_args()
    # Note: All handlers must have **kwargs to handle global args
    parsed_args.handler(**parsed_args.__dict__)


def cut(files_and_times: List[str], copy, av, av_mid, mid, smid, small, smaller, smallest, scale, quality, mv, **global_args):
    args = files_and_times

    video_args = []
    output_suffix = "_CUT"
    preset = {
        av: ["av", "-c:a aac -c:v libsvtav1 -pix_fmt yuv420p -preset 8 -crf {quality}", 1920, 30],
        av_mid: ["av_mid", "-c:a aac -c:v libsvtav1 -pix_fmt yuv420p -preset 8 -crf {quality}", 1920, 39],
        # GPU encode, faster but lower quality per bitrate
        # av: ["av", "-c:a aac -c:v av1_nvenc -multipass 2 -preset p7 -cq {quality}" , 1920, 32],
        mid: ["mid", "-c:a aac -c:v libx264 -pix_fmt yuv420p -b:v 3M -maxrate 3M -bufsize 10M", 1920, None],
        smid: ["smid", "-c:a aac -c:v libx264 -pix_fmt yuv420p -b:v 2M -maxrate 2M -bufsize 10M", 1280, None],
        small: ["small", "-c:a aac -c:v hevc_nvenc -rc vbr -cq {quality}", 1280, 35], # -cq and -crf are different scales
        smaller: ["smaller", "-c:a aac -c:v libx264 -pix_fmt yuv420p -crf {quality}", 1280, 28],
        smallest: ["smallest", "-c:a aac -c:v libx265 -crf {quality}", 1280, 28],
    }.get(True)

    if copy:
        video_args = "-c copy".split(" ")
    elif preset:
        key = preset[0]
        video_args = preset[1]
        scale = scale or preset[2]
        quality = quality or preset[3]
        output_suffix = f"_{scale}_{key.upper()}"
        if quality:
            video_args = video_args.format(quality=quality)
            output_suffix += f"_{quality}"
        video_args = video_args.split(" ")
    if scale:
        h_scale = round(int(scale) * 1080 / 1920)
        # scale down to scale - but not up, and keep aspect ratio
        scale_filter = f"scale='if(gt(iw/ih,1920/1080),min(iw,{scale}),-1)':'if(gt(iw/ih,1920/1080),-1,min(ih,{h_scale}))'"
    else:
        scale_filter = None

    files_to_process = []

    print("video args:", video_args)

    i = 0
    while i < len(args):
        file = args[i]
        if not os.path.exists(file):
            print("File does not exist:", file)
            sys.exit(1)
        i += 1
        cuts = []
        while i < len(args) and ":" in args[i]:
            cuts.append(args[i])
            i += 1
        if len(cuts) % 2 != 0:
            print("Error: cuts must be in pairs")
            sys.exit(1)
        files_to_process.append((file, cuts))

    if len(files_to_process) == 0:
        print("No files to process")
        sys.exit(0)

    if len(files_to_process) == 1 and len(files_to_process[0][1]) == 0 and len(video_args) == 2:
        print("Just one file and nothing to cut")
        sys.exit(0)
    output_file = os.path.splitext(args[0])[0] + output_suffix + ".mp4"

    if mv:
        subdir = "ffcut-done"
        if not os.path.exists(subdir):
            os.makedirs(subdir)
        output_file = os.path.join(subdir, output_file)

    if len(files_to_process) == 1 and len(files_to_process[0][1]) <= 2:
        direct_cut(files_to_process, output_file, video_args, scale_filter)
    else:
        multi_file_cut(files_to_process, output_file, video_args, scale_filter)

    if mv:
        for f in files_to_process:
            move_to_dir(f[0], "ffcut-source")


def direct_cut(files_to_process: List[str], output_file: str, video_args, scale_filter):
    print("Using direct cut mode")
    if scale_filter:
        video_args += ["-vf", scale_filter]
    file = files_to_process[0][0]
    if len(files_to_process[0][1]) >= 2:
        start, end = files_to_process[0][1]
        subprocess.check_call(["ffmpeg", "-ss", start, "-to", end, "-i", file] + video_args + [output_file])
    else:
        subprocess.check_call(["ffmpeg", "-i", file] + video_args + [output_file])


def multi_file_cut(files_to_process: List[str], output_file: str, video_args, scale_filter):
    print("Using multi cut mode (concat filter, no temp files)")

    input_args = []
    segment_count = 0
    for file, cuts in files_to_process:
        if not cuts:
            input_args += ["-i", file]
            segment_count += 1
        else:
            for i in range(0, len(cuts), 2):
                start = cuts[i]
                end = cuts[i+1]
                input_args += ["-ss", start, "-to", end, "-i", file]
                segment_count += 1

    # TODO this can fail is files have different resolutions or framerates
    # color fix: -pix_fmt yuv420p -profile:v high
    filter_complex = ""
    if scale_filter:
        filter_complex += ";".join(f"[{i}:v]{scale_filter}[v{i}]" for i in range(segment_count)) + ";"
        filter_complex += "".join(f"[v{i}][{i}:a]" for i in range(segment_count))
    else:
        filter_complex = "".join(f"[{i}:v][{i}:a]" for i in range(segment_count))
    filter_complex += f"concat=n={segment_count}:v=1:a=1[outv][outa]"

    cmd = (
        ["ffmpeg"]
        + input_args
        + ["-filter_complex", filter_complex, "-map", "[outv]", "-map", "[outa]"]
        + video_args
        + [output_file]
    )
    print("Running:", " ".join(cmd))
    subprocess.check_call(cmd)


# OLD DEPRECATED - but could work better for different files with different codecs ?
# does seem to have some audio offset issues though
def OLD_multi_file_cut(files_to_process: List[str], output_file: str, video_args):
    print("Using multi cut mode")

    random_id = os.urandom(4).hex()
    files_to_merge = []
    tmp_files = []

    for file, cuts in files_to_process:
        for i in range(0, len(cuts), 2):
            s = list(map(int, cuts[i].split(":")))
            e = list(map(int, cuts[i+1].split(":")))
            while len(s) < len(e):
                s = [0] + s
            if e <= s:
                print("Error", cuts[i], "must be before", cuts[i+1])
                quit(1)

    for file, cuts in files_to_process:
        if len(cuts) == 0:
            files_to_merge.append(file)
            continue
        for i in range(0, len(cuts), 2):
            start, end = cuts[i], cuts[i + 1]
            cut_file = f"tmpffcut_{file.replace(' ', '_')}_{random_id}_{start.replace(':', '_')}_{end.replace(':', '_')}.mp4".replace("'", "-")
            subprocess.check_call(["ffmpeg", "-ss", start, "-to", end, "-i", file, "-c", "copy", cut_file])
            tmp_files.append(cut_file)
            files_to_merge.append(cut_file)

    # write files_to_merge to a file
    tmp_file_list = f"tmpffcut_{random_id}.txt"
    with open(tmp_file_list, "w") as f:
        for file in files_to_merge:
            f.write(f"file '{file}'\n")

    time.sleep(1)

    subprocess.check_call(["ffmpeg", "-f", "concat", "-safe", "0", "-i", tmp_file_list] + video_args + [output_file])

    for tmp_file in tmp_files:
        if os.path.exists(tmp_file):
            os.remove(tmp_file)
    os.remove(tmp_file_list)


def move_to_dir(file: str, subdir: str):
    if not os.path.exists(subdir):
        os.makedirs(subdir)
    shutil.move(file, subdir)


if __name__ == '__main__':
    main()
