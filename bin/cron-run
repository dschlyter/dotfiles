#!/usr/bin/env python3

# Run cron scripts with logging, success callback and error callback

# Pro tip: PATH=... on top of file to make cron behave like your shell
import json
import os
import sys
import subprocess
from subprocess import Popen, PIPE, STDOUT

from datetime import datetime

scriptPath = os.path.realpath(os.path.dirname(sys.argv[0]))
os.chdir(scriptPath)

LOG_DIR = os.environ['HOME']+'/.logs/cron-run/'
# PRO TIP: a default config is stored in the scripts repository
CONF = os.environ['HOME']+'/.config/cron-run.json'


def main():
    if len(sys.argv) < 3:
        print("Usage cron-run command-name [next-run-in-days] command ...")
        sys.exit(1)

    try:
        run_and_report()
    except Exception as ex:
        job_name = sys.argv[1] if len(sys.argv) > 1 else 'unknown'
        report_error(job_name, "cron-run internal error " + str(ex))


def run_and_report():
    run_id = datetime.now().isoformat()
    job_name, next_run, cmd = parse(sys.argv)

    p = Popen(cmd, shell=True, stdout=PIPE, stderr=PIPE, close_fds=True)
    code = p.wait()

    stdout = p.stdout.read().decode('utf-8') if p.stdout else ""
    stderr = p.stderr.read().decode('utf-8') if p.stderr else ""
    print(stdout)
    print(stderr)
    print("job returned", code)

    if not os.path.exists(LOG_DIR):
        os.makedirs(LOG_DIR)

    log_data = [run_id, "stdout:"]
    log_data += stdout.split("\n")
    log_data.append("stderr:")
    log_data += stderr.split("\n")

    with open("{}/{}.log".format(LOG_DIR, job_name), 'a') as file:
        file.write("\n\n")
        file.write("\n".join(log_data))

    if code != 0:
        report_error(job_name, stderr)
    report_status(job_name, run_id, "success" if code == 0 else "error", next_run, log_data)


def parse(argv):
    job_name = argv[1]
    next_run = 7

    cmd_start = 2
    if argv[2].isdigit():
        next_run = int(argv[2])
        cmd_start = 3

    cmd = " ".join(argv[cmd_start:])
    return job_name, next_run, cmd


def report_error(job_name, error_msg):
    print("reporting error", error_msg)
    conf = load_conf(CONF, {})
    slack_url = conf.get('slack')
    if slack_url:
        json_data = json.dumps({
            'username': 'cron-run',
            'icon_emoji': ':ghost:',
            'text': '{} failed :/ Error: {}'.format(job_name, error_msg),
        })
        subprocess.check_call(['curl', '-X', 'POST', '--data-urlencode', 'payload='+json_data, slack_url])
        print("Error hook poked")
    else:
        print("Unable to load conf, cannot trigger error hook")


def report_status(job_name, run_id, status, next_run, logs):
    conf = load_conf(CONF, {})
    url = conf.get('healthcheck')
    if url:
        report_url = os.path.join(url, job_name, run_id)
        json_data = json.dumps({
            'run_id': run_id,
            'status': status,
            'next': next_run,
            'log': logs,
        })
        subprocess.check_call(['curl', '-X', 'PUT', '-H', 'Content-Type: application/json', '--data', json_data, report_url])
        print("Healthcheck service informed")
    else:
        print("Unable to load conf, cannot update healthcheck")


def load_conf(path, default_value=None):
    try:
        with open(path, 'r') as data_file:
            return json.load(data_file)
    except (FileNotFoundError, json.JSONDecodeError):
        return default_value if default_value is not None else {}


if __name__ == '__main__':
    main()
