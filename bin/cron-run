#!/usr/bin/env python3

# Run cron scripts with logging, success callback and error callback

# PRO TIP: PATH=... on top of crontab to make cron behave like your shell
# PRO TIP: a default config is stored in the scripts repository

import json
import os
import sys
import subprocess
import socket
import io
import time
from subprocess import Popen, PIPE
from pathlib import Path
from datetime import datetime

HOME = str(Path.home())
LOG_DIR = HOME+'/.logs/cron-run/'
CONF = HOME+'/.config/cron-run.json'


def main():
    if len(sys.argv) < 3:
        print("Usage cron-run command-name [next-run-in-days] command ...")
        sys.exit(1)

    try:
        run_and_report()
    except Exception as ex:
        job_name = sys.argv[1] if len(sys.argv) > 1 else 'unknown'
        report_error(job_name, "cron-run internal error " + str(ex), Log())
        raise ex


def run_and_report():
    start = time.time()
    log = Log()
    log.append(datetime.now().isoformat())

    job_name, next_run, cmd = parse(sys.argv)
    log.append(str(cmd))

    p = Popen(cmd, stdout=PIPE, stderr=subprocess.STDOUT, close_fds=True)
    
    # Stream output while running the command
    # Run this command with python -u to get snappy output
    stdout_b = b''
    while True:
        bytes = p.stdout.read(1)
        if not bytes:
            break
        stdout_b += bytes
        sys.stdout.buffer.write(bytes)
    p.stdout.close()
    code = p.wait()
    
    stdout_rows = stdout_b.decode('utf-8', errors='replace').splitlines()
    log.append_all(stdout_rows, output=False)
    log.append(f"job returned {code}")
    log.append(f"completed in {time.time() - start} seconds")

    if not os.path.exists(LOG_DIR):
        os.makedirs(LOG_DIR)

    with open("{}/{}.log".format(LOG_DIR, job_name), encoding='utf-8', mode='a') as file:
        file.write("\n\n")
        file.write("\n".join(log.log_data))

    if code != 0:
        report_error(job_name, "\n".join(log.log_data), log)
        
    report_status(job_name, "success" if code == 0 else "error", next_run, log.log_data)


def parse(argv):
    job_name = argv[1]
    next_run = 7

    cmd_start = 2
    if argv[2].isdigit():
        next_run = int(argv[2])
        cmd_start = 3

    cmd = argv[cmd_start:]
    return job_name, next_run, cmd


def report_error(job_name, error_msg, log):
    error_msg = error_msg[:1000]

    log.append("reporting error to slack")
    conf = load_conf(CONF, {})
    slack_url = conf.get('slack')
    if slack_url:
        json_data = json.dumps({
            'username': 'cron-run',
            'icon_emoji': ':ghost:',
            'text': '{} failed :/ Error: {}'.format(job_name, error_msg),
        })
        subprocess.check_call(['curl', '-X', 'POST', '--data-urlencode', 'payload='+json_data, slack_url])
        log.append("Error hook poked")
    else:
        log.append("Unable to load conf, cannot trigger error hook")


def report_status(job_name, status, next_run, logs):
    conf = load_conf(CONF, {})
    url = conf.get('healthcheck')
    if url:
        report_url = os.path.join(url, job_name)
        json_data = json.dumps({
            'status': status,
            'next': next_run,
            'host': socket.gethostname(),
            'log': logs,
        })
        p = Popen(['curl', '-X', 'POST', '-H', 'Content-Type: application/json', '--data', '@-', report_url], stdin=PIPE)
        p.communicate(input=json_data.encode('utf-8'))[0]
        print("Healthcheck service informed")
    else:
        print("Unable to load conf, cannot update healthcheck")


def load_conf(path, default_value=None):
    try:
        with open(path, 'r') as data_file:
            return json.load(data_file)
    except (FileNotFoundError, json.JSONDecodeError):
        return default_value if default_value is not None else {}


class Log:
    def __init__(self):
        self.log_data = []

    def append(self, line, output=True):
        if output:
            print(line)
        self.log_data.append(line)

    def append_all(self, lines, output=True):
        for line in lines:
            self.append(line, output=output)


if __name__ == '__main__':
    main()
