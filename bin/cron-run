#!/usr/bin/env python3

# Run cron scripts with logging, success callback and error callback

# Pro tip: PATH=... on top of file to make cron behave like your shell
import json
import os
import sys
import subprocess
import socket
from subprocess import Popen, PIPE

from datetime import datetime

scriptPath = os.path.realpath(os.path.dirname(sys.argv[0]))
os.chdir(scriptPath)

LOG_DIR = os.environ['HOME']+'/.logs/cron-run/'
# PRO TIP: a default config is stored in the scripts repository
CONF = os.environ['HOME']+'/.config/cron-run.json'


def main():
    if len(sys.argv) < 3:
        print("Usage cron-run command-name [next-run-in-days] command ...")
        sys.exit(1)

    try:
        run_and_report()
    except Exception as ex:
        job_name = sys.argv[1] if len(sys.argv) > 1 else 'unknown'
        report_error(job_name, "cron-run internal error " + str(ex))


def run_and_report():
    log = Log()
    log.append(datetime.now().isoformat())

    job_name, next_run, cmd = parse(sys.argv)

    log.append(cmd)

    p = Popen(cmd, shell=True, stdout=PIPE, stderr=PIPE, close_fds=True)
    code = p.wait()

    stdout = p.stdout.read().decode('utf-8') if p.stdout else ""
    stderr = p.stderr.read().decode('utf-8') if p.stderr else ""

    log.append("stdout:")
    log.append_all(stdout.split("\n"))
    log.append("stderr:")
    log.append_all(stderr.split("\n"))
    log.append("job returned "+str(code))

    if not os.path.exists(LOG_DIR):
        os.makedirs(LOG_DIR)

    with open("{}/{}.log".format(LOG_DIR, job_name), 'a') as file:
        file.write("\n\n")
        file.write("\n".join(log.log_data))

    if code != 0:
        report_error(job_name, stderr)
    report_status(job_name, "success" if code == 0 else "error", next_run, log.log_data)


def parse(argv):
    job_name = argv[1]
    next_run = 7

    cmd_start = 2
    if argv[2].isdigit():
        next_run = int(argv[2])
        cmd_start = 3

    cmd = " ".join(argv[cmd_start:])
    return job_name, next_run, cmd


def report_error(job_name, error_msg, log):
    log.append("reporting error "+str(error_msg))
    conf = load_conf(CONF, {})
    slack_url = conf.get('slack')
    if slack_url:
        json_data = json.dumps({
            'username': 'cron-run',
            'icon_emoji': ':ghost:',
            'text': '{} failed :/ Error: {}'.format(job_name, error_msg),
        })
        subprocess.check_call(['curl', '-X', 'POST', '--data-urlencode', 'payload='+json_data, slack_url])
        log.append("Error hook poked")
    else:
        log.append("Unable to load conf, cannot trigger error hook")


def report_status(job_name, status, next_run, logs):
    conf = load_conf(CONF, {})
    url = conf.get('healthcheck')
    if url:
        report_url = os.path.join(url, job_name)
        json_data = json.dumps({
            'status': status,
            'next': next_run,
            'host': socket.gethostname(),
            'log': logs,
        })
        subprocess.check_call(['curl', '-X', 'POST', '-H', 'Content-Type: application/json', '--data', json_data, report_url])
        print("Healthcheck service informed")
    else:
        print("Unable to load conf, cannot update healthcheck")


def load_conf(path, default_value=None):
    try:
        with open(path, 'r') as data_file:
            return json.load(data_file)
    except (FileNotFoundError, json.JSONDecodeError):
        return default_value if default_value is not None else {}


class Log:
    def __init__(self):
        self.log_data = []

    def append(self, line):
        print(line)
        self.log_data.append(line)

    def append_all(self, lines):
        for line in lines:
            self.append(line)


if __name__ == '__main__':
    main()
