#!/usr/bin/env python3

# 5 * * * * PATH="$HOME/.dotfiles/bin:$PATH" TO_WIN=1 cron-run --name halation-win-git-bak --daily --health-slo 21 git-bak "$HOME/linux-code" /mnt/d/Dropbox/code
# NOTE: Add TO_WIN=1 if you are backuping from wsl FS to windows FS

import os
import subprocess
import sys
import time
from pathlib import Path


def usage():
    print("""
git-bak code-dir backup-dir
moves all git content from dir to backup-dir (for example dropbox)
    """.strip())


def main():
    if len(sys.argv) < 3:
        usage()
        sys.exit(0)

    try:
        last_error = None
        src_root = os.path.join(os.getcwd(), sys.argv[1])
        target_root = os.path.join(os.getcwd(), sys.argv[2])

        os.chdir(src_root)
        ignores = load_ignores(src_root)

        repos = sh_read("find . -maxdepth 3 -type d -name .git").split("\n")
        for git_dir in repos:
            repo_dir = Path(git_dir).parent
            if str(repo_dir) in ignores:
                print("Skipping ignored repo", repo_dir)
                continue

            src = os.path.join(src_root, repo_dir)
            target = os.path.join(target_root, repo_dir)
            try:
                backup_git(src, target)
            except Exception as e:
                print(f"git-bak failed for {src} to {target}: {e}")
                last_error = e
        if last_error:
            raise last_error
    except Exception as e:
        alert(str(e))
        raise e


def load_ignores(src_root):
    ignore_file = os.path.join(src_root, ".gitbakignore")
    if os.path.exists(ignore_file):
        with open(ignore_file) as fp:
            return set([line.strip() for line in fp])

    return set()


def backup_git(src, target):
    os.chdir(src)
    src_remote = get_remote()
    src_origin_commit = sh_read("git rev-parse origin/master").strip()

    GIT_EXEC = ["git"]
    if os.environ.get("TO_WIN") == "1":
        # use Windows executable since linux executable assumes POSIX and closes files that windows FS considers in use, causing errors
        # all paths must be converted to windows format as well - otherwise git.exe runs in a weird hybrid mode that fails on some operations
        win_target = cmd_read("wslpath", "-w", target)
        GIT_EXEC = ["git.exe", "-C", win_target]
        src = cmd_read("wslpath", "-w", src)
        print("Rewrote paths to", src, win_target)

    print("Backing up", src, target)

    if not os.path.exists(target):
        print(f"Creating directory {target}")
        os.makedirs(target)
        os.chdir(target)
        # cmd(*GIT_EXEC, "init", "--bare")
        cmd(*GIT_EXEC, "init")
    else:
        os.chdir(target)
    if os.environ.get("TO_WIN") == "1" and cmd_read(*GIT_EXEC, "config", "--get", "core.filemode") != "false":
        os.chdir(os.path.expanduser("~"))
        # avoid dealing with a bunch of file permission issues on windows side
        print("Disabling core.filemode on windows backup repo")
        cmd(*GIT_EXEC, "config", "core.filemode", "false")

    # cmd(*GIT_EXEC, "fetch", src, "master:master")
    cmd(*GIT_EXEC, "pull", "--no-rebase", src, "master:master")
    print("Pull complete")

    target_remote = get_remote(GIT_EXEC)
    if src_remote:
        if not target_remote:
            print("Adding remote "+src_remote)
            cmd(*GIT_EXEC, "remote", "add", "origin", src_remote)
        elif src_remote != target_remote:
            print("Setting remote to "+src_remote)
            cmd(*GIT_EXEC, "remote", "set-url", "origin", src_remote)

    try:
        target_origin_commit = cmd_read(*GIT_EXEC, "rev-parse", "origin/master")
    except subprocess.CalledProcessError:
        target_origin_commit = None
    if src_origin_commit != target_origin_commit:
        print("Updating origin/master to", src_origin_commit)
        time.sleep(1)
        cmd(*GIT_EXEC, "update-ref", "refs/remotes/origin/master", src_origin_commit)
    print()


def get_remote(GIT_EXEC=["git"]):
    try:
        DEVNULL = open(os.devnull, 'wb')
        r = subprocess.check_output(GIT_EXEC + ["remote", "get-url", "origin"], stderr=DEVNULL)
        return r.decode("utf-8").strip()
    except Exception as e:
        return None


def sh_read(command):
    return subprocess.check_output(command, shell=True).decode('utf-8').strip()


def cmd(*args):
    print("Running command:", " ".join(args))
    return subprocess.check_call(args)


def cmd_read(*args):
    return subprocess.check_output(args).decode('utf-8').strip()


def alert(message):
    script_dir = os.path.dirname(os.path.realpath(__file__))
    alert_script = os.path.join(script_dir, "alert")
    subprocess.check_call([alert_script, message])


if __name__ == '__main__':
    main()
